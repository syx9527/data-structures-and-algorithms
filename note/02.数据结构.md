# 数据结构

[TOC]

- 数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成。
- 简单来说，数据结构就是设计数据以任何方式组织并存储再计算机中。
- 比如：列表、集合与字典等都是一种数据结构。
- `N.Wirth`：”$程序=数据结构+算法$“

- 数据结构按照其逻辑结构可分为线性结构、树结构、图结构
    - 线性结构：数据结构中元素存在一对一的相互关系
    - 树结构：数据结构中红的元素存在一对多的相互关系
    - 图结构：数据结构中的元素存在多对多的相互关系

# 栈

- 栈$(Stack)$是一个数据集合，可以理解为只能在一端进行插入后者删除操作的列表。
- 栈的特点：先进后出$\ LIFO \ (last-in,\ first-out)$
- 栈的概念：栈顶，栈底
- 栈的基本操作：
    - 进栈(压栈)：`push`
    - 出栈：`pop`
    - 取栈顶：`gettop`
- 使用一般的列表结构杰克实现栈：
    - 进栈(压栈)：`li.append()`
    - 出栈：`li.pop()`
    - 取栈顶：`li[-1]`
- 栈的应用——括号匹配问题
    - 括号匹配问题：给一个字符串，其中包括小括号、中括号、大括号，求该字符串中的括号是否匹配。
    - 例如：
        - ()(){}				匹配
        - ([{()}])			匹配
        - [](		 		不匹配
        - [(])				不匹配

# 队列

- 队列$(Queue)$是一个数据集合，仅允许在列表的一段进行插入，另一端进行删除。

- 进行插入的一端称为队尾$(rear)$，插入动作称为进队或者入队

- 进行删除的一端称为队头$(front)$，删除动作称为出队

- 队列的性质：先进先出$(First-in,First-out)$

    <img src="./img/image-20220608155934840.png" alt="image-20220608155934840" style="zoom: 40%;" />

- 队列的实现方式

## 环形队列

<img src="./img/image-20220608162848247.png" alt="image-20220608162848247" style="zoom:35%;" />

- 环形队列：当队尾指针`front==Maxsize + 1`时，再前进一个位置就自动到0.
    - 队首指针前进1：`front = (front + 1) % Maxsize`
    - 队尾指针前进1：`rear = (rear+ 1) % Maxsize`
    - 队空条件：`rear == front`
    - 队满条件：`(rear + 1) % Maxsize ==front`

## 双向队列

- 双向队列的两端都支持进队和出队操作

- 双向队列的基本操作：

    - 队首进队
    - 队首出队
    - 队尾进队
    - 队尾出
    

<img src="./img/image-20220609095714971.png" alt="image-20220609095714971" style="zoom:40%;" />

## Python队列内置模块

- 使用方法：`from collections import deque`
    - 创建队列：`queue = deque()`
    - 进队：`append()`
    - 出队：`popleft()`
    - 双向队列队首进队：`appendleft()`
    - 双向队列队尾出队：`pop()`

# 栈和队列的应用——迷宫问题

- 给一个二维列表，表示迷宫（0表示通道，1表示围墙）。位处算法，求一条走出迷宫的路径。

    <img src=".\img\image-20220609105504888.png" alt="image-20220609105504888" style="zoom:30%;" /><img src=".\img\image-20220609105554531.png" alt="image-20220609105554531" style="zoom:40%;" />
    
    ```python
    # 迷宫
    maze = [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],
        [1, 0, 0, 1, 0, 0, 0, 1, 0, 1],
        [1, 0, 0, 0, 0, 1, 1, 0, 0, 1],
        [1, 0, 1, 1, 1, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 0, 1, 0, 0, 0, 1, 0, 0, 1],
        [1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
        [1, 1, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ]
    
    # 四个方向
    dirs = [
        lambda x, y: (x + 1, y),
        lambda x, y: (x - 1, y),
        lambda x, y: (x, y - 1),
        lambda x, y: (x, y + 1),
    ]
    ```
    
    

**栈——深度优先搜索**

- 回溯法

- 思路：从一个节点开始，任意找下一个能走的点，当找不到能走的点时，退回上一个点寻找是否有其他方向的点。

- 使用栈存储当前路径

    ```python
    def maze_path(x1: int, y1: int, x2: int, y2: int) -> bool:
        """
        深度优先
        :param x1:起点横坐标
        :param y1:起点纵坐标
        :param x2:终点横坐标
        :param y2:终点纵坐标
        :return: True or False
        """
        stack = []
        stack.append((x1, y1))
        while len(stack) > 0:
            cur_node = stack[-1]  # 当前的节点
            if cur_node[0] == x2 and cur_node[1] == y2:
                # 表示走到终点了
                for p in stack:
                    print(p)
                return True
            # x,t 四个方向 上(x-1,y),下：(x+1,y),左(x,y-1),右(x,y+1)
            for dir_ in dirs:
                next_node = dir_(cur_node[0], cur_node[1])
                # 如果下一个节点能走：
                if maze[next_node[0]][next_node[1]] == 0:
                    stack.append((next_node))
                    maze[next_node[0]][next_node[1]] = 2  # 标记已经走过了
                    break
            else:
                maze[next_node[0]][next_node[1]] = 2
                stack.pop()
    
        else:
            print("没有路！")
            return False
    
    
    maze_path(1, 1, 8, 8)
    ```

    

**栈——广优先搜索**

- 思路：从一个节点开始，寻找所有接下来能继续走的点，继续不断寻找，直到找到出口。

- 使用队列存储当前正在考虑的节点

    ```python
    def maze_path_queue(x1: int, y1: int, x2: int, y2: int) -> bool:
        """
        广度优先
        :param x1:起点横坐标
        :param y1:起点纵坐标
        :param x2:终点横坐标
        :param y2:终点纵坐标
        :return: True or False
        """
        queue = deque()
        queue.append((x1, y1, -1))
        path_: List[int] = []
        while queue:
            cur_node = queue.popleft()
            path_.append(cur_node)
            if cur_node[0] == x2 and cur_node[1] == y2:
                # 表示走到终点了
                print_path(path_)
                return True
            for dir_ in dirs:
                next_node = dir_(cur_node[0], cur_node[1])
                if maze[next_node[0]][next_node[1]] == 0:
                    queue.append((next_node[0], next_node[1], len(path_) - 1))
                    maze[next_node[0]][next_node[1]] = 2  # 标记为已经走过
        else:
            print("没有路！")
            return False
    ```

# 链表

- 链表是由一系列节点组成的元素集合。每个节点包含两部分，数据域item和指向下一个节点的指针next。通过节点之间的相互连接，最终串联成一个链表。

    ```python
    class Node:
        def __init__(self, item, next=None):
            self.item = item
            self.next = next
    ```

    ![image-20220616110600336](.\img\image-20220616110600336.png)

## 创建链表

- 头插法

<img src=".\img\image-20220616110756173.png" alt="image-20220616110756173" style="zoom:30%;" />

<img src=".\img\image-20220616110849408.png" alt="image-20220616110849408" style="zoom:30%;" />

```python
def create_linklist_head(li: List[int]) -> Node:
    """
    头插法
    :param li:
    :return:
    """
    head = Node(li[0])
    for element in li[1:]:
        node = Node(element)
        node.next = head
        head = node
    return head
```



- 尾插法

<img src="D:\数据结构与算法_python\note\img\image-20220616110916442.png" alt="image-20220616110916442" style="zoom:30%;" />

```python
def create_linklist_tail(li: List[int]) -> Node:
    """
    尾插法
    :param li:
    :return:
    """
    head = Node(li[0])
    tail = head
    for element in li[1:]:
        node = Node(element)
        tail.next = node
        tail = node
    return head
```

## 链表节点的插入

<img src=".\img\image-20220616112535049.png" alt="image-20220616112535049" style="zoom:30%;" />

1. `p.next = curNode.next`
2. `curNode.next = p`